import modal
import logging
import ast
import io
import contextlib

app = modal.App("code_interpreter") # creates container to store all info for code interpreter

test_cases = [
    {"input": [[10, 20, 4, 45, 99]], "expected_output": 45},  # Normal case
    {"input": [[5, 5, 5, 5]], "expected_output": None},  # All elements are the same
    {"input": [[1, 2]], "expected_output": 1},  # Only two elements
    {"input": [[100]], "expected_output": None},  # Only one element
    {"input": [[-5, -1, -10, -3]], "expected_output": -3},  # Negative numbers
    {"input": [[3, 3, 5, 5, 7, 7]], "expected_output": 5}  # Duplicates with a valid second largest
]

user_code = """
def user_function(nums):
    print("Hello World")
    unique_nums = list(set(nums))  # Remove duplicates
    if len(unique_nums) < 2:
        return None
    unique_nums.sort()
    return unique_nums[-2]
"""

faulty_solution_code = """
def user_function(nums):
    if len(nums) < 2:
        return None
    nums.sort()  # Sorts in ascending order
    return nums[-2]  # Returns the second-to-last element
"""

def extract_function(user_code: str):
    try:
        parsed_code = ast.parse(user_code) # parses the code as an abstract syntax tree
        for node in ast.walk(parsed_code): # checks each node in the tree which is each line of code in user_code
            if isinstance(node, ast.FunctionDef): # checks if the node is a function definition
                return node.name
    except Exception as e:
        return None

@app.function()
def interpret_code(user_code: str, test_cases: list): # should take the users code and test cases generated by groq
    print("ACCESSING INTERPRETING CODE")
    exec_globals = {}

    try:
        exec(user_code, exec_globals) # running the code and putting the results in exec_globals
        user_func = exec_globals.get(extract_function(user_code)) # getting the user function from the code

        results = []

        for test_case in test_cases:
            try:
                with io.StringIO() as buf, contextlib.redirect_stdout(buf): # redirecting the output of the code to a buffer
                    result = user_func(*test_case["input"]) # takes user's input from user code and runs it with the test case input
                    stdoutput = buf.getvalue() # gets the output from the buffer

                results.append({
                    "input": test_case["input"],
                    "expected": test_case["expected_output"],
                    "output": result,
                    "std output": stdoutput,
                    "passed": result == test_case["expected_output"]
                })
                logging.info(f"Test case passed: {result == test_case['expected_output']}") # logs if the test case passed or failed
            except Exception as e:
                results.append(
                    {
                        "input": test_case["input"],
                        "expected": test_case["expected_output"],
                        "output": result,
                        "std output": stdoutput,
                        "passed": result == test_case["expected_output"],
                    }
                )  # if the code fails, it adds the test case to the results

        return results

    except Exception as e:
        return {"error": str(e)}  # failsafe in case the code is invalid


if __name__ == "__main__":
    # For local testing without Modal deployment
    results = interpret_code.local(user_code, test_cases)
    print(results)
    
    # Print results in a readable format
    # print("\nTest Results:")
    # if isinstance(results, dict) and "error" in results:
    #     print(f"Error: {results['error']}")
    # else:
    #     for i, result in enumerate(results, 1):
    #         print(f"\nTest Case {i}:")
    #         print(f"Input: {result['input']}")
    #         print(f"Expected: {result['expected']}")
    #         print(f"Got: {result['output']}")
    #         print(f"Std Output: {result['std output']}")
    #         print(f"Passed: {result['passed']}")
